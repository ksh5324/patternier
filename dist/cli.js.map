{"version":3,"sources":["../src/cli.ts","../src/config/loadConfig.ts","../src/pattern/fsd/fsMeta.ts","../src/core/parse.ts","../src/utils/makeOffsetToLoc.ts","../src/pattern/fsd/constants.ts","../src/pattern/fsd/utils/shouldSkipByLayer.ts","../src/pattern/fsd/utils/nomalizeRule.ts","../src/pattern/fsd/utils/extractTarget.ts","../src/pattern/fsd/rules/noLayerToHigherImport.ts","../src/pattern/fsd/rules/noCrossSliceImport.ts","../src/pattern/fsd/rules/uiNoSideEffects.ts","../src/pattern/fsd/rules/sliceNoUsage.ts","../src/pattern/fsd/rules/modelNoPresentation.ts","../src/pattern/fsd/rules/useClientOnlyUi.ts","../src/pattern/fsd/rules/noDeepImport.ts","../src/pattern/fsd/rules/index.ts","../src/utils/resolveImport.ts","../src/pattern/fsd/inspect.ts","../src/entry/inspectByType.ts","../src/utils/formatDiagnostic.ts","../src/utils/readIgnoreFile.ts"],"sourcesContent":["// src/cli.ts\nimport path from \"node:path\";\nimport fs from \"node:fs/promises\";\nimport { loadConfig } from \"./config/loadConfig\";\nimport { inspectByType } from \"./entry/inspectByType\";\nimport { formatDiagnostic } from \"./utils/formatDiagnostic\";\nimport picomatch from \"picomatch\";\nimport { readIgnoreFile } from \"./utils/readIgnoreFile\";\n\n\nconst cwd = process.cwd();\n\nfunction usage() {\n  console.log(`patternier\n\nUsage:\n  patternier inspect <file>\n  patternier check [file]\n\nExamples:\n  pnpm dev inspect fixtures/features/a/index.ts\n  pnpm dev check fixtures/features/a/index.ts\n  pnpm dev check\n`);\n}\n\nconst SOURCE_EXTS = new Set([\".js\", \".jsx\", \".ts\", \".tsx\", \".mjs\", \".cjs\"]);\n\n// 기본 ignore는 config가 없어도 적용\nconst DEFAULT_IGNORES = [\n  \"**/node_modules/**\",\n  \"**/dist/**\",\n  \"**/.git/**\",\n] as const;\n\nfunction normalizeRel(p: string) {\n  return p.replaceAll(path.sep, \"/\");\n}\n\nfunction makeIsIgnored(ignores: readonly string[]) {\n  // picomatch는 배열 패턴을 받아 matcher 함수를 만들어줌\n  const matcher = picomatch(ignores as string[]);\n  return (relPath: string) => matcher(relPath);\n}\n\nasync function listSourceFiles(\n  dir: string,\n  opts: { isIgnored: (relPath: string) => boolean }\n): Promise<string[]> {\n  const out: string[] = [];\n\n  async function walk(current: string) {\n    const entries = await fs.readdir(current, { withFileTypes: true });\n\n    for (const e of entries) {\n      // 빠른 디렉토리 스킵 (glob과 별개로 성능/안전)\n      if (e.name === \"node_modules\" || e.name === \"dist\" || e.name === \".git\") continue;\n\n      const full = path.join(current, e.name);\n\n      if (e.isDirectory()) {\n        // 디렉토리도 ignore 매칭되면 아예 하위 스캔 안 함 (성능↑)\n        const relDir = normalizeRel(path.relative(dir, full));\n        if (opts.isIgnored(relDir) || opts.isIgnored(relDir + \"/**\")) continue;\n\n        await walk(full);\n        continue;\n      }\n\n      if (e.isFile()) {\n        const ext = path.extname(e.name).toLowerCase();\n        if (!SOURCE_EXTS.has(ext)) continue;\n\n        const relFile = normalizeRel(path.relative(dir, full));\n        if (opts.isIgnored(relFile)) continue;\n\n        out.push(full);\n      }\n    }\n  }\n\n  await walk(dir);\n  return out;\n}\n\nasync function main() {\n  const [, , cmd, fileArg] = process.argv;\n\n  if (!cmd) return usage();\n\n  const repoRoot = cwd;\n  const config = await loadConfig(repoRoot);\n  const analysisRoot = path.join(repoRoot, config.rootDir ?? \".\");\n\n  const userIgnores = config.ignores ?? [];\n  const ignoreFilePatterns = await readIgnoreFile(path.join(repoRoot, \".patternierignore\"));\n\n  const ignores = [\n    ...DEFAULT_IGNORES,\n    ...ignoreFilePatterns,\n    ...userIgnores,\n  ];\n\n  const isIgnored = makeIsIgnored(ignores);\n\n  const ctx = { repoRoot, analysisRoot, config };\n\n  async function resolveFileArg(p: string) {\n    const absPath = path.isAbsolute(p) ? p : path.join(repoRoot, p);\n    const ext = path.extname(absPath).toLowerCase();\n    if (!SOURCE_EXTS.has(ext)) {\n      throw new Error(`Unsupported file extension: ${ext}`);\n    }\n    const st = await fs.stat(absPath);\n    if (!st.isFile()) {\n      throw new Error(`Not a file: ${absPath}`);\n    }\n    return absPath;\n  }\n\n  if (cmd === \"inspect\") {\n    if (!fileArg) return usage();\n\n    try {\n      const absPath = await resolveFileArg(fileArg);\n\n      // inspect는 보통 강제 분석이 편하지만, 원하면 ignore도 적용 가능\n      // 여기서는 \"inspect는 무조건 실행\"으로 둔다.\n      const result = await inspectByType(config.type, absPath, ctx);\n      process.stdout.write(JSON.stringify(result, null, 2) + \"\\n\");\n    } catch (e: any) {\n      console.error(e?.message || e);\n      process.exitCode = 1;\n    }\n    return;\n  }\n\n  if (cmd === \"check\") {\n    let targets: string[] = [];\n\n    if (fileArg) {\n      let absPath: string;\n      try {\n        absPath = await resolveFileArg(fileArg);\n      } catch (e: any) {\n        console.error(e?.message || e);\n        process.exitCode = 1;\n        return;\n      }\n\n      // ✅ check <file>도 ignores 적용 (원하면 나중에 --no-ignore 추가)\n      const rel = normalizeRel(path.relative(analysisRoot, absPath));\n      if (rel.startsWith(\"..\")) {\n        // analysisRoot 밖이면 그냥 검사(사용자가 명시했으니까)\n        targets = [absPath];\n      } else if (!isIgnored(rel)) {\n        targets = [absPath];\n      } else {\n        // ignore 대상이면 조용히 통과 처리\n        process.exitCode = 0;\n        return;\n      }\n    } else {\n      // ✅ 인자 없으면 rootDir 하위 전체 검사 + ignores 필터\n      targets = await listSourceFiles(analysisRoot, { isIgnored });\n    }\n\n    let hasError = false;\n\n    for (const absPath of targets) {\n      let result: any;\n      try {\n        result = await inspectByType(config.type, absPath, ctx);\n      } catch (e: any) {\n        hasError = true;\n        console.error(e?.message || e);\n        continue;\n      }\n      const diags = result?.diagnostics ?? [];\n\n      if (diags.length > 0) {\n        hasError = true;\n        for (const d of diags) {\n          process.stdout.write(formatDiagnostic(result.file.relPath, d) + \"\\n\");\n        }\n      }\n    }\n\n    process.exitCode = hasError ? 1 : 0;\n    return;\n  }\n\n  usage();\n}\n\nmain().catch((e) => {\n  console.error(e?.stack || e);\n  process.exitCode = 1;\n});\n","// src/config/loadConfig.ts\nimport path from \"node:path\";\nimport { pathToFileURL } from \"node:url\";\nimport fs from \"node:fs\";\n\nexport async function loadConfig(repoRoot: string) {\n  const configPath = path.join(repoRoot, \"patternier.config.mjs\");\n\n\n  if (!fs.existsSync(configPath)) {\n    // config 없으면 기본값\n    return { type: \"fsd\" as const };\n  }\n\n  const mod = await import(pathToFileURL(configPath).href);\n\n  const cfg = mod?.config ?? mod?.default ?? null;\n  if (!cfg || typeof cfg !== \"object\") {\n    throw new Error(`Invalid config export in ${configPath}. Export \"config\" object.`);\n  }\n  return cfg;\n}\n","// src/inspect/fsMeta.ts\nimport path from \"node:path\";\n\nconst FSD_LAYERS = [\"app\", \"apps\", \"pages\", \"widgets\", \"features\", \"entities\", \"shared\"] as const;\n\nexport function getFsMeta(absPath: string, repoRoot: string) {\n  const relPath = path.relative(repoRoot, absPath).replaceAll(path.sep, \"/\");\n  const parts = relPath.split(\"/\");\n\n  const layer = (FSD_LAYERS as readonly string[]).includes(parts[0] ?? \"\")\n    ? (parts[0] as (typeof FSD_LAYERS)[number])\n    : \"unknown\";\n\n  // slice: features/<slice>/..., entities/<slice>/...\n  const slice =\n    (layer === \"features\" || layer === \"entities\" || layer === \"widgets\") && parts.length >= 2\n      ? parts[1]\n      : null;\n\n  return {\n    absPath,\n    relPath,\n    layer,\n    slice,\n  };\n}\n","// src/pattern/fsd/parse.ts\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport * as swc from \"@swc/core\";\nimport { makeOffsetToLoc } from \"@/utils/makeOffsetToLoc\";\n\nfunction locFromSpan(\n  span: any,\n  offsetToLoc: (n: number) => { line: number; col: number },\n  baseOffset: number\n) {\n  if (!span || typeof span.start !== \"number\") return null;\n  const relOffset = span.start - baseOffset + 1;\n  return offsetToLoc(relOffset > 0 ? relOffset : span.start);\n}\n\nexport async function parseFile(absPath: string) {\n  const code = await fs.readFile(absPath, \"utf8\");\n  const { offsetToLoc } = makeOffsetToLoc(code);\n\n  const ext = path.extname(absPath).toLowerCase();\n\n  const syntax = ext === \".ts\" || ext === \".tsx\" ? \"typescript\" : \"ecmascript\";\n  const tsx = ext === \".tsx\" || ext === \".jsx\";\n\n  const ast = await swc.parse(code, {\n    syntax,\n    tsx,\n    decorators: true,\n    dynamicImport: true,\n  } as any);\n\n  const baseOffset = (ast as any).span?.start ?? 1;\n\n  const imports: any[] = [];\n  const exports: any[] = [];\n  const requires: any[] = [];\n  const dynamicImports: any[] = [];\n  const fetchCalls: any[] = [];\n  const jsxUsages: any[] = [];\n  const templateLiterals: any[] = [];\n  let useClient = false;\n\n  function walk(node: any) {\n    if (!node || typeof node !== \"object\") return;\n    if (Array.isArray(node)) {\n      for (const n of node) walk(n);\n      return;\n    }\n\n    if (node.type === \"CallExpression\") {\n      const callee = node.callee;\n      const isFetchIdent = callee?.type === \"Identifier\" && callee.value === \"fetch\";\n      const isFetchMember =\n        callee?.type === \"MemberExpression\" &&\n        callee.property?.type === \"Identifier\" &&\n        callee.property.value === \"fetch\";\n      if (isFetchIdent || isFetchMember) {\n        fetchCalls.push({ loc: locFromSpan(node.span, offsetToLoc, baseOffset) });\n      }\n    }\n\n    if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n      jsxUsages.push({ loc: locFromSpan(node.span, offsetToLoc, baseOffset) });\n    }\n\n    if (node.type === \"TemplateLiteral\") {\n      templateLiterals.push({ loc: locFromSpan(node.span, offsetToLoc, baseOffset) });\n    }\n\n    for (const key of Object.keys(node)) {\n      if (key === \"span\") continue;\n      const value = (node as any)[key];\n      if (value && typeof value === \"object\") walk(value);\n    }\n  }\n\n  for (const stmt of (ast as any).body ?? []) {\n    if (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression?.type === \"StringLiteral\" &&\n      stmt.expression.value === \"use client\"\n    ) {\n      useClient = true;\n    }\n\n    if (stmt.type === \"ImportDeclaration\") {\n      imports.push({\n        kind: \"esm\",\n        source: stmt.source?.value ?? null,\n        typeOnly: !!stmt.typeOnly,\n        specifiers: (stmt.specifiers ?? []).map((s: any) => ({\n          type: s.type, // ImportDefaultSpecifier / ImportNamespaceSpecifier / ImportSpecifier\n          local: s.local?.value ?? null,\n          imported: s.imported?.value ?? null,\n        })),\n        loc: locFromSpan(stmt.span, offsetToLoc, baseOffset),\n      });\n      if (stmt.source?.value === \"axios\" || stmt.source?.value?.startsWith(\"axios/\")) {\n        fetchCalls.push({ loc: locFromSpan(stmt.span, offsetToLoc, baseOffset) });\n      }\n      continue;\n    }\n\n    if (stmt.type === \"ExportAllDeclaration\") {\n      exports.push({\n        kind: \"exportAll\",\n        source: stmt.source?.value ?? null,\n        loc: locFromSpan(stmt.span, offsetToLoc, baseOffset),\n      });\n      continue;\n    }\n\n    if (stmt.type === \"ExportNamedDeclaration\") {\n      exports.push({\n        kind: \"exportNamed\",\n        source: stmt.source?.value ?? null,\n        specifiers: (stmt.specifiers ?? []).map((s: any) => ({\n          type: s.type,\n          local: s.orig?.value ?? null,\n          exported: s.exported?.value ?? null,\n        })),\n        loc: locFromSpan(stmt.span, offsetToLoc, baseOffset),\n      });\n      continue;\n    }\n  }\n\n  walk(ast as any);\n\n  return {\n    imports,\n    exports,\n    requires,\n    dynamicImports,\n    fetchCalls,\n    jsxUsages,\n    templateLiterals,\n    directives: { useClient },\n  };\n}\n","function makeOffsetToLoc(code: string) {\n  const lineStartByteOffsets: number[] = [0];\n  const lineStartCodeUnitOffsets: number[] = [0];\n  const charByteOffsets: number[] = [];\n  const charCodeUnitOffsets: number[] = [];\n\n  let byteOffset = 0;\n  let codeUnitOffset = 0;\n\n  for (const ch of code) {\n    charByteOffsets.push(byteOffset);\n    charCodeUnitOffsets.push(codeUnitOffset);\n\n    const byteLen = Buffer.byteLength(ch, \"utf8\");\n    const codeUnitLen = ch.length;\n\n    if (ch === \"\\n\") {\n      lineStartByteOffsets.push(byteOffset + byteLen);\n      lineStartCodeUnitOffsets.push(codeUnitOffset + codeUnitLen);\n    }\n\n    byteOffset += byteLen;\n    codeUnitOffset += codeUnitLen;\n  }\n\n  function byteOffsetToCodeUnitOffset(offset: number) {\n    let lo = 0;\n    let hi = charByteOffsets.length - 1;\n    let idx = -1;\n    while (lo <= hi) {\n      const mid = (lo + hi) >> 1;\n      if (charByteOffsets[mid] <= offset) {\n        idx = mid;\n        lo = mid + 1;\n      } else {\n        hi = mid - 1;\n      }\n    }\n    return idx >= 0 ? charCodeUnitOffsets[idx] : 0;\n  }\n\n  function offsetToLoc(offset: number) {\n    // 마지막 lineStartOffsets <= offset 찾기 (이진탐색)\n    let lo = 0;\n    let hi = lineStartByteOffsets.length - 1;\n    while (lo <= hi) {\n      const mid = (lo + hi) >> 1;\n      if (lineStartByteOffsets[mid] <= offset) lo = mid + 1;\n      else hi = mid - 1;\n    }\n    const lineIndex = Math.max(0, lo - 1);\n    const line = lineIndex + 1;\n    const codeUnitAt = byteOffsetToCodeUnitOffset(offset);\n    const col = codeUnitAt - lineStartCodeUnitOffsets[lineIndex] + 1; // 1-based\n    return { line, col };\n  }\n\n  return { offsetToLoc };\n}\n\nexport { makeOffsetToLoc };\n","export const DEFAULT_FSD_LAYER_ORDER = [\n    \"app\",\n    \"pages\",\n    \"widgets\",\n    \"features\",\n    \"entities\",\n    \"shared\",\n] as const;","import { NormalizedRuleSetting } from \"./nomalizeRule\";\n\nfunction shouldSkipByLayer(fileLayer: string, setting: NormalizedRuleSetting) {\n    if (setting.include?.length) return !setting.include.includes(fileLayer);\n    if (setting.exclude?.length) return setting.exclude.includes(fileLayer);\n    return false;\n  }\n\nexport { shouldSkipByLayer };","type Level = \"off\" | \"warn\" | \"error\";\n\nexport type NormalizedRuleSetting = {\n  level: Level | string;\n  include?: string[];\n  exclude?: string[];\n  options?: any;\n};\n\nexport function normalizeRuleSetting(x: any, defaultSetting: NormalizedRuleSetting): NormalizedRuleSetting {\n  if (x === \"off\" || x === \"warn\" || x === \"error\") \n    return { \n      level: x, \n      include: defaultSetting.include, \n      exclude: defaultSetting.exclude, \n      options: defaultSetting.options \n    };\n  if (x && typeof x === \"object\") {\n    return {\n      level: (x.level ?? defaultSetting.level) as Level,\n      include: x.include ?? defaultSetting.include,\n      exclude: x.exclude ?? defaultSetting.exclude,\n      options: x.options ?? defaultSetting.options,\n    };\n  }\n\n  return defaultSetting;\n}\n","// src/pattern/fsd/utils/extractTarget.ts\nexport type LayerName = \"app\" | \"pages\" | \"widgets\" | \"features\" | \"entities\" | \"shared\" | string;\n\nconst LAYERS: LayerName[] = [\"app\", \"pages\", \"widgets\", \"features\", \"entities\", \"shared\"];\n\nexport function extractTargetFromSource(source: string): { layer: LayerName; slice: string | null } | null {\n  // 허용 케이스:\n  // \"@/features/auth/...\" or \"features/auth/...\"\n  const normalized = source.startsWith(\"@/\") ? source.slice(2) : source;\n\n  const parts = normalized.split(\"/\").filter(Boolean);\n  const layer = parts[0] as LayerName | undefined;\n\n  if (!layer || !LAYERS.includes(layer)) return null;\n\n  const slice = (layer === \"features\" || layer === \"entities\" || layer === \"widgets\") && parts.length >= 2\n    ? parts[1]\n    : null;\n\n  return { layer, slice };\n}\n\nexport function getLayerIndex(layer: LayerName, order: readonly LayerName[]) {\n  return order.indexOf(layer);\n}\n","// src/pattern/fsd/rules/noLayerToHigherImport.ts\nimport type { LayerName } from \"../utils/extractTarget\";\nimport { extractTargetFromSource, getLayerIndex } from \"../utils/extractTarget\";\n\ntype Loc = { line: number; col: number } | null;\n\nexport type Diagnostic = {\n  ruleId: string;\n  message: string;\n  loc: Loc;\n};\n\nexport type NoLayerToHigherImportOptions = {\n  // 상위 -> 하위 방향을 허용하는 \"정렬\"\n  // app(가장 상위) ... shared(가장 하위)\n  order: readonly LayerName[];\n};\n\nexport function noLayerToHigherImportRule(\n  ctx: {\n    file: { relPath: string; layer: string; slice: string | null };\n    imports: { source: string | null; loc: Loc; target?: { layer: LayerName } | null }[];\n  },\n  opts: NoLayerToHigherImportOptions\n): Diagnostic[] {\n  const diags: Diagnostic[] = [];\n\n  const fromLayer = ctx.file.layer as LayerName;\n  const fromIdx = getLayerIndex(fromLayer, opts.order);\n  if (fromIdx === -1) return diags; // unknown layer면 패스\n\n  for (const im of ctx.imports) {\n    const src = im.source;\n    if (!src) continue;\n\n    const target = im.target ?? extractTargetFromSource(src);\n    if (!target) continue;\n\n    const toIdx = getLayerIndex(target.layer, opts.order);\n    if (toIdx === -1) continue;\n\n    // \"higher\"는 index가 더 작은 쪽(app이 0)\n    const isImportingHigher = toIdx < fromIdx;\n\n    if (isImportingHigher) {\n      diags.push({\n        ruleId: \"@patternier/no-layer-to-higher-import\",\n        message: `${fromLayer} cannot import from higher layer ${target.layer}.`,\n        loc: im.loc ?? null,\n      });\n    }\n  }\n\n  return diags;\n}\n","// src/pattern/fsd/rules/noCrossSliceImport.ts\nimport { extractTargetFromSource } from \"../utils/extractTarget\";\n\ntype Loc = { line: number; col: number } | null;\n\nexport type Diagnostic = {\n  ruleId: string;\n  message: string;\n  loc: Loc;\n};\n\nexport type NoCrossSliceImportOptions = {\n  // 기본: features만 강제\n  layers: readonly string[];\n};\n\nexport function noCrossSliceImportRule(\n  ctx: {\n    file: { relPath: string; layer: string; slice: string | null };\n    imports: { source: string | null; loc: Loc; target?: { layer: string; slice: string | null } | null }[];\n  },\n  opts: NoCrossSliceImportOptions\n): Diagnostic[] {\n  const diags: Diagnostic[] = [];\n\n  const fromLayer = ctx.file.layer;\n  const fromSlice = ctx.file.slice;\n\n  if (!opts.layers.includes(fromLayer)) return diags;\n  if (!fromSlice) return diags;\n\n  for (const im of ctx.imports) {\n    const src = im.source;\n    if (!src) continue;\n\n    const target = im.target ?? extractTargetFromSource(src);\n    if (!target) continue;\n\n    // 같은 layer 내에서 slice가 다른 곳으로 가는 것만 금지\n    if (target.layer === fromLayer) {\n      const toSlice = target.slice;\n      if (toSlice && toSlice !== fromSlice) {\n        diags.push({\n          ruleId: \"@patternier/no-cross-slice-import\",\n          message: `${fromLayer}/${fromSlice} cannot import from ${fromLayer}/${toSlice}. Use shared/entities or expose via public API.`,\n          loc: im.loc ?? null,\n        });\n      }\n    }\n  }\n\n  return diags;\n}\n","type Loc = { line: number; col: number } | null;\n\ntype UiNoSideEffectsContext = {\n  file: { relPath: string };\n  imports: { source: string | null; loc?: Loc }[];\n  fetchCalls?: { loc: Loc }[];\n};\n\nconst RULE_ID = \"@patternier/ui-no-side-effects\";\n\nfunction isUiFile(relPath: string) {\n  return relPath.split(\"/\").includes(\"ui\");\n}\n\nexport function uiNoSideEffectsRule(ctx: UiNoSideEffectsContext) {\n  const diags: { ruleId: string; message: string; loc: Loc }[] = [];\n\n  if (!isUiFile(ctx.file.relPath)) return diags;\n\n  for (const fc of ctx.fetchCalls ?? []) {\n    diags.push({\n      ruleId: RULE_ID,\n      message: \"ui cannot use fetch/axios. Move side-effects to api/model layer.\",\n      loc: fc.loc ?? null,\n    });\n  }\n\n  return diags;\n}\n","type Loc = { line: number; col: number } | null;\n\ntype SliceNoUsageContext = {\n  file: { relPath: string; layer: string };\n};\n\nconst RULE_ID = \"@patternier/slice-no-usage\";\n\nconst TARGET_LAYERS = new Set([\"features\", \"pages\", \"entities\", \"widgets\", \"apps\"]);\nconst RESERVED_SEGMENTS = new Set([\n  \"ui\",\n  \"model\",\n  \"lib\",\n  \"utils\",\n  \"config\",\n  \"types\",\n  \"constants\",\n  \"assets\",\n  \"styles\",\n  \"hooks\",\n]);\n\nfunction hasMissingSlice(relPath: string, layer: string) {\n  const parts = relPath.split(\"/\").filter(Boolean);\n  if (!layer || !TARGET_LAYERS.has(layer)) return false;\n\n  const second = parts[1];\n  if (!second) return true;\n  if (second.includes(\".\")) return true;\n  if (RESERVED_SEGMENTS.has(second)) return true;\n\n  return false;\n}\n\nexport function sliceNoUsageRule(ctx: SliceNoUsageContext) {\n  const diags: { ruleId: string; message: string; loc: Loc }[] = [];\n\n  if (!hasMissingSlice(ctx.file.relPath, ctx.file.layer)) return diags;\n\n  diags.push({\n    ruleId: RULE_ID,\n    message: \"layer requires a slice folder: <layer>/<slice>/...\",\n    loc: null,\n  });\n\n  return diags;\n}\n","type Loc = { line: number; col: number } | null;\n\ntype ModelNoPresentationContext = {\n  file: { relPath: string };\n  parsed?: {\n    jsxUsages?: { loc: Loc }[];\n    templateLiterals?: { loc: Loc }[];\n  };\n};\n\nconst RULE_ID = \"@patternier/model-no-presentation\";\n\nfunction isModelPath(relPath: string) {\n  return relPath.split(\"/\").includes(\"model\");\n}\n\nexport function modelNoPresentationRule(ctx: ModelNoPresentationContext) {\n  const diags: { ruleId: string; message: string; loc: Loc }[] = [];\n\n  if (!isModelPath(ctx.file.relPath)) return diags;\n\n  const jsxLocs = ctx.parsed?.jsxUsages ?? [];\n  const tmplLocs = ctx.parsed?.templateLiterals ?? [];\n\n  for (const j of jsxLocs) {\n    diags.push({\n      ruleId: RULE_ID,\n      message: \"model cannot use JSX. Keep model layer pure.\",\n      loc: j.loc ?? null,\n    });\n  }\n\n  for (const t of tmplLocs) {\n    diags.push({\n      ruleId: RULE_ID,\n      message: \"model cannot use template literals. Keep model layer pure.\",\n      loc: t.loc ?? null,\n    });\n  }\n\n  return diags;\n}\n","import picomatch from \"picomatch\";\n\ntype Loc = { line: number; col: number } | null;\n\ntype UseClientOnlyUiContext = {\n  file: { relPath: string };\n  parsed?: { directives?: { useClient?: boolean } };\n};\n\ntype UseClientOnlyUiOptions = {\n  exclude?: string[];\n  allow?: string[] | string;\n};\n\nconst RULE_ID = \"@patternier/use-client-only-ui\";\nconst DEFAULT_ALLOW = [\"**/ui/**\"];\n\nfunction matches(patterns: string[] | undefined, relPath: string) {\n  if (!patterns || patterns.length === 0) return false;\n  return picomatch(patterns)(relPath);\n}\n\nexport function useClientOnlyUiRule(ctx: UseClientOnlyUiContext, opts?: UseClientOnlyUiOptions) {\n  const diags: { ruleId: string; message: string; loc: Loc }[] = [];\n\n  if (!ctx.parsed?.directives?.useClient) return diags;\n\n  const relPath = ctx.file.relPath;\n  const allow = Array.isArray(opts?.allow) ? opts?.allow : opts?.allow ? [opts.allow] : DEFAULT_ALLOW;\n\n  if (matches(opts?.exclude, relPath)) return diags;\n  if (matches(allow, relPath)) return diags;\n\n  diags.push({\n    ruleId: RULE_ID,\n    message: '\"use client\" is only allowed under ui paths.',\n    loc: null,\n  });\n\n  return diags;\n}\n","type Loc = { line: number; col: number } | null;\n\ntype NoDeepImportContext = {\n  file: { relPath: string };\n  imports: { source: string | null; loc?: Loc }[];\n};\n\ntype NoDeepImportOptions = {\n  maxDepth?: number;\n};\n\nconst RULE_ID = \"@patternier/no-deep-import\";\n\nfunction getImportDepth(src: string) {\n  const normalized = src.startsWith(\"@/\") ? src.slice(2) : src;\n  const parts = normalized.split(\"/\").filter(Boolean);\n  return parts.length;\n}\n\nexport function noDeepImportRule(ctx: NoDeepImportContext, opts?: NoDeepImportOptions) {\n  const diags: { ruleId: string; message: string; loc: Loc }[] = [];\n  const maxDepth = opts?.maxDepth ?? 3;\n\n  for (const im of ctx.imports) {\n    const src = im.source;\n    if (!src) continue;\n    if (src.startsWith(\".\")) continue;\n\n    const depth = getImportDepth(src);\n    if (depth > maxDepth) {\n      diags.push({\n        ruleId: RULE_ID,\n        message: `deep import is not allowed. Max depth is ${maxDepth}.`,\n        loc: im.loc ?? null,\n      });\n    }\n  }\n\n  return diags;\n}\n","import { noLayerToHigherImportRule } from \"./noLayerToHigherImport\";\nimport { noCrossSliceImportRule } from \"./noCrossSliceImport\";\nimport { uiNoSideEffectsRule } from \"./uiNoSideEffects\";\nimport { sliceNoUsageRule } from \"./sliceNoUsage\";\nimport { modelNoPresentationRule } from \"./modelNoPresentation\";\nimport { useClientOnlyUiRule } from \"./useClientOnlyUi\";\nimport { noDeepImportRule } from \"./noDeepImport\";\nimport type { RuleSetting } from \"@/config/rules\";\n\nexport type FsdRuleSettings = Partial<{\n  /** Prevent importing higher-level layers from lower-level ones. */\n  \"@patternier/no-layer-to-higher-import\": RuleSetting;\n  /** Block cross-slice imports within the same layer (default: features). */\n  \"@patternier/no-cross-slice-import\": RuleSetting;\n  /** Disallow side-effects (fetch/axios) inside ui paths. */\n  \"@patternier/ui-no-side-effects\": RuleSetting;\n  /** Enforce <layer>/<slice>/... structure for slice-based layers. */\n  \"@patternier/slice-no-usage\": RuleSetting;\n  /** Disallow JSX/template literals inside model paths (opt-in). */\n  \"@patternier/model-no-presentation\": RuleSetting;\n  /** Allow \"use client\" only under ui paths. Options: { allow?: string[]; exclude?: string[] } */\n  \"@patternier/use-client-only-ui\": RuleSetting;\n  /** Disallow deep imports beyond maxDepth (default: 3). */\n  \"@patternier/no-deep-import\": RuleSetting;\n}>;\n\nexport const fsdRuleRegistry = {\n  \"@patternier/no-layer-to-higher-import\": {\n    run: noLayerToHigherImportRule,\n    default: {\n        level: \"error\",\n    }\n  },\n  \"@patternier/no-cross-slice-import\": {\n    run: noCrossSliceImportRule,\n    default: {\n        level: \"error\",\n        options: { layers: [\"features\"] }\n    }\n  },\n  \"@patternier/ui-no-side-effects\": {\n    run: uiNoSideEffectsRule,\n    default: {\n        level: \"error\",\n    }\n  },\n  \"@patternier/slice-no-usage\": {\n    run: sliceNoUsageRule,\n    default: {\n        level: \"error\",\n        exclude: [\"shared\"]\n    }\n  },\n  \"@patternier/model-no-presentation\": {\n    run: modelNoPresentationRule,\n    default: {\n        level: \"off\",\n    }\n  },\n  \"@patternier/use-client-only-ui\": {\n    run: useClientOnlyUiRule,\n    default: {\n        level: \"off\",\n        options: { allow: [\"**/ui/**\"] }\n    }\n  },\n  \"@patternier/no-deep-import\": {\n    run: noDeepImportRule,\n    default: {\n        level: \"off\",\n        options: { maxDepth: 3 }\n    }\n  }\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\n\ntype Tsconfig = {\n  baseUrl: string;\n  paths: Record<string, string[]>;\n};\n\nconst TS_EXTS = [\".ts\", \".tsx\", \".js\", \".jsx\", \".mjs\", \".cjs\"];\nconst tsconfigCache = new Map<string, Tsconfig | null>();\n\nasync function loadTsconfig(repoRoot: string): Promise<Tsconfig | null> {\n  if (tsconfigCache.has(repoRoot)) return tsconfigCache.get(repoRoot) ?? null;\n  const tsconfigPath = path.join(repoRoot, \"tsconfig.json\");\n  if (!fs.existsSync(tsconfigPath)) {\n    tsconfigCache.set(repoRoot, null);\n    return null;\n  }\n  const raw = await fs.promises.readFile(tsconfigPath, \"utf8\");\n  const data = JSON.parse(raw);\n  const compilerOptions = data?.compilerOptions ?? {};\n  const baseUrl = compilerOptions.baseUrl ?? \".\";\n  const paths = compilerOptions.paths ?? {};\n  const cfg = { baseUrl, paths } as Tsconfig;\n  tsconfigCache.set(repoRoot, cfg);\n  return cfg;\n}\n\nfunction tryResolveFile(absPath: string): string | null {\n  if (path.extname(absPath)) {\n    if (fs.existsSync(absPath)) return absPath;\n  }\n\n  for (const ext of TS_EXTS) {\n    const cand = absPath + ext;\n    if (fs.existsSync(cand)) return cand;\n  }\n\n  for (const ext of TS_EXTS) {\n    const cand = path.join(absPath, \"index\" + ext);\n    if (fs.existsSync(cand)) return cand;\n  }\n\n  return null;\n}\n\nfunction resolveRelative(source: string, fromFile: string): string | null {\n  if (!source.startsWith(\".\")) return null;\n  const base = path.resolve(path.dirname(fromFile), source);\n  return tryResolveFile(base);\n}\n\nfunction escapeRegex(s: string) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nfunction resolveWithPaths(source: string, repoRoot: string, cfg: Tsconfig): string | null {\n  const entries = Object.entries(cfg.paths);\n  for (const [pattern, targets] of entries) {\n    if (!pattern) continue;\n    const hasStar = pattern.includes(\"*\");\n    if (!hasStar) {\n      if (pattern === source) {\n        for (const t of targets) {\n          const absBase = path.resolve(repoRoot, cfg.baseUrl, t);\n          const resolved = tryResolveFile(absBase);\n          if (resolved) return resolved;\n        }\n      }\n      continue;\n    }\n\n    const re = new RegExp(\"^\" + escapeRegex(pattern).replace(\"\\\\*\", \"(.+)\") + \"$\");\n    const m = source.match(re);\n    if (!m) continue;\n    const star = m[1] ?? \"\";\n    for (const t of targets) {\n      const replaced = t.replace(\"*\", star);\n      const absBase = path.resolve(repoRoot, cfg.baseUrl, replaced);\n      const resolved = tryResolveFile(absBase);\n      if (resolved) return resolved;\n    }\n  }\n  return null;\n}\n\nexport async function resolveImportSource(\n  source: string | null,\n  fromFile: string,\n  repoRoot: string\n): Promise<string | null> {\n  if (!source) return null;\n  if (source.startsWith(\".\"))\n    return resolveRelative(source, fromFile);\n\n  const cfg = await loadTsconfig(repoRoot);\n  if (cfg) {\n    const byPaths = resolveWithPaths(source, repoRoot, cfg);\n    if (byPaths) return byPaths;\n  }\n\n  if (source.startsWith(\"@/\")) {\n    const absBase = path.resolve(repoRoot, source.slice(2));\n    return tryResolveFile(absBase);\n  }\n\n  return null;\n}\n","// src/pattern/fsd/inspect.ts\nimport { getFsMeta } from \"./fsMeta\";\nimport { parseFile } from \"@/core/parse\";\nimport { PatternConfig } from \"@/config/definePatternConfig\";\nimport { DEFAULT_FSD_LAYER_ORDER } from \"./constants\";\nimport { shouldSkipByLayer } from \"./utils/shouldSkipByLayer\";\nimport { normalizeRuleSetting } from \"./utils/nomalizeRule\";\nimport { fsdRuleRegistry } from \"./rules\";\nimport { resolveImportSource } from \"@/utils/resolveImport\";\n\nexport async function inspectFile(\n  absPath: string,\n  ctx: { repoRoot: string; analysisRoot: string; config: PatternConfig }\n) {\n  const file = getFsMeta(absPath, ctx.analysisRoot);\n  const parsed = await parseFile(absPath);\n\n  // 룰 옵션에 들어갈 공통 컨텍스트(예: layer order)\n  const layerOrder = ctx.config.layers?.order ?? DEFAULT_FSD_LAYER_ORDER;\n\n  const diagnostics: any[] = [];\n\n  const resolvedImports = await Promise.all(\n    parsed.imports.map(async (im) => {\n      const resolvedPath = await resolveImportSource(im.source, absPath, ctx.repoRoot);\n      const target = resolvedPath ? getFsMeta(resolvedPath, ctx.analysisRoot) : null;\n      return { ...im, resolvedPath, target };\n    })\n  );\n\n  const userRules = ctx.config.rules ?? {};\n\n  for (const [ruleId, rule] of Object.entries(fsdRuleRegistry)) {\n    // 1) 사용자 설정 가져오기 (없으면 default)\n    const userSettingRaw = (userRules as any)[ruleId];\n    const setting = normalizeRuleSetting(userSettingRaw, rule.default);\n\n    // 2) off면 스킵\n    if (setting.level === \"off\") continue;\n\n    // 3) include/exclude(layer 기준) 적용\n    if (shouldSkipByLayer(file.layer, setting)) continue;\n\n    // 4) rule options 구성 (공통 + 유저)\n\n    const options = {\n      // 공통 옵션들\n      order: layerOrder,\n      // 유저가 rule별로 넣은 options\n      ...(setting.options ?? {}),\n    };\n\n    // 5) 실행\n    const diags = rule.run(\n      {\n        file,\n        imports: resolvedImports,\n        fetchCalls: parsed.fetchCalls,\n        parsed,\n      },\n      options\n    );\n\n    // 6) level 주입\n    for (const d of diags) {\n      diagnostics.push({ ...d, level: setting.level });\n    }\n  }\n\n  return { file, ...parsed, diagnostics };\n}\n","// src/entry/inspectByType.ts\nimport { PatternType } from \"@/config/definePatternConfig\";\nimport {inspectFile as inspectFsd} from \"../pattern/fsd/inspect\";\n\nexport async function inspectByType(\n  type: PatternType,\n  absPath: string,\n  ctx: { repoRoot: string; analysisRoot: string; config: any }\n) {\n  switch (type) {\n    case \"fsd\":\n      return inspectFsd(absPath, ctx);\n    default: return inspectFsd(absPath, ctx);\n  }\n}\n","export function formatDiagnostic(\n    filePath: string,\n    d: {\n      ruleId: string;\n      message: string;\n      loc?: { line: number; col: number } | null;\n    }\n  ) {\n    const pos = d.loc ? `${d.loc.line}:${d.loc.col}` : \"0:0\";\n    return `${filePath}:${pos}  ${d.ruleId}  ${d.message}`;\n  }\n  ","// src/utils/readIgnoreFile.ts\nimport fs from \"node:fs/promises\";\n\nexport async function readIgnoreFile(absPath: string): Promise<string[]> {\n  try {\n    const raw = await fs.readFile(absPath, \"utf8\");\n    return raw\n      .split(/\\r?\\n/g)\n      .map((l) => l.trim())\n      .filter((l) => l.length > 0)\n      .filter((l) => !l.startsWith(\"#\"));\n  } catch (e: any) {\n    if (e?.code === \"ENOENT\") return [];\n    throw e;\n  }\n}\n"],"mappings":"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","names":["path","fs","path","fs","path","fs","path","RULE_ID","RULE_ID","RULE_ID","RULE_ID","fs","path","picomatch","fs","path","picomatch","fs"]}
{"version":3,"sources":["../src/cli.ts","../src/config/loadConfig.ts","../src/pattern/fsd/fsMeta.ts","../src/core/parse.ts","../src/utils/makeOffsetToLoc.ts","../src/pattern/fsd/constants.ts","../src/pattern/fsd/utils/shouldSkipByLayer.ts","../src/pattern/fsd/utils/nomalizeRule.ts","../src/pattern/fsd/utils/extractTarget.ts","../src/pattern/fsd/rules/noLayerToHigherImport.ts","../src/pattern/fsd/rules/noCrossSliceImport.ts","../src/pattern/fsd/rules/index.ts","../src/pattern/fsd/inspect.ts","../src/entry/inspectByType.ts","../src/utils/formatDiagnostic.ts","../src/utils/readIgnoreFile.ts"],"sourcesContent":["// src/cli.ts\nimport path from \"node:path\";\nimport fs from \"node:fs/promises\";\nimport { loadConfig } from \"./config/loadConfig\";\nimport { inspectByType } from \"./entry/inspectByType\";\nimport { formatDiagnostic } from \"./utils/formatDiagnostic\";\nimport picomatch from \"picomatch\";\nimport { readIgnoreFile } from \"./utils/readIgnoreFile\";\n\n\nconst cwd = process.cwd();\n\nfunction usage() {\n  console.log(`patternier\n\nUsage:\n  patternier inspect <file>\n  patternier check [file]\n\nExamples:\n  pnpm dev inspect fixtures/features/a/index.ts\n  pnpm dev check fixtures/features/a/index.ts\n  pnpm dev check\n`);\n}\n\nconst SOURCE_EXTS = new Set([\".js\", \".jsx\", \".ts\", \".tsx\", \".mjs\", \".cjs\"]);\n\n// 기본 ignore는 config가 없어도 적용\nconst DEFAULT_IGNORES = [\n  \"**/node_modules/**\",\n  \"**/dist/**\",\n  \"**/.git/**\",\n] as const;\n\nfunction normalizeRel(p: string) {\n  return p.replaceAll(path.sep, \"/\");\n}\n\nfunction makeIsIgnored(ignores: readonly string[]) {\n  // picomatch는 배열 패턴을 받아 matcher 함수를 만들어줌\n  const matcher = picomatch(ignores as string[]);\n  return (relPath: string) => matcher(relPath);\n}\n\nasync function listSourceFiles(\n  dir: string,\n  opts: { isIgnored: (relPath: string) => boolean }\n): Promise<string[]> {\n  const out: string[] = [];\n\n  async function walk(current: string) {\n    const entries = await fs.readdir(current, { withFileTypes: true });\n\n    for (const e of entries) {\n      // 빠른 디렉토리 스킵 (glob과 별개로 성능/안전)\n      if (e.name === \"node_modules\" || e.name === \"dist\" || e.name === \".git\") continue;\n\n      const full = path.join(current, e.name);\n\n      if (e.isDirectory()) {\n        // 디렉토리도 ignore 매칭되면 아예 하위 스캔 안 함 (성능↑)\n        const relDir = normalizeRel(path.relative(dir, full));\n        if (opts.isIgnored(relDir) || opts.isIgnored(relDir + \"/**\")) continue;\n\n        await walk(full);\n        continue;\n      }\n\n      if (e.isFile()) {\n        const ext = path.extname(e.name).toLowerCase();\n        if (!SOURCE_EXTS.has(ext)) continue;\n\n        const relFile = normalizeRel(path.relative(dir, full));\n        if (opts.isIgnored(relFile)) continue;\n\n        out.push(full);\n      }\n    }\n  }\n\n  await walk(dir);\n  return out;\n}\n\nasync function main() {\n  const [, , cmd, fileArg] = process.argv;\n\n  if (!cmd) return usage();\n\n  const repoRoot = cwd;\n  const config = await loadConfig(repoRoot);\n  const analysisRoot = path.join(repoRoot, config.rootDir ?? \".\");\n\n  const userIgnores = config.ignores ?? [];\n  const ignoreFilePatterns = await readIgnoreFile(path.join(repoRoot, \".patternierignore\"));\n\n  const ignores = [\n    ...DEFAULT_IGNORES,\n    ...ignoreFilePatterns,\n    ...userIgnores,\n  ];\n\n  const isIgnored = makeIsIgnored(ignores);\n\n  const ctx = { repoRoot, analysisRoot, config };\n\n  if (cmd === \"inspect\") {\n    if (!fileArg) return usage();\n\n    const absPath = path.isAbsolute(fileArg) ? fileArg : path.join(repoRoot, fileArg);\n\n    // inspect는 보통 강제 분석이 편하지만, 원하면 ignore도 적용 가능\n    // 여기서는 \"inspect는 무조건 실행\"으로 둔다.\n    const result = await inspectByType(config.type, absPath, ctx);\n    process.stdout.write(JSON.stringify(result, null, 2) + \"\\n\");\n    return;\n  }\n\n  if (cmd === \"check\") {\n    let targets: string[] = [];\n\n    if (fileArg) {\n      const absPath = path.isAbsolute(fileArg) ? fileArg : path.join(repoRoot, fileArg);\n\n      // ✅ check <file>도 ignores 적용 (원하면 나중에 --no-ignore 추가)\n      const rel = normalizeRel(path.relative(analysisRoot, absPath));\n      if (rel.startsWith(\"..\")) {\n        // analysisRoot 밖이면 그냥 검사(사용자가 명시했으니까)\n        targets = [absPath];\n      } else if (!isIgnored(rel)) {\n        targets = [absPath];\n      } else {\n        // ignore 대상이면 조용히 통과 처리\n        process.exitCode = 0;\n        return;\n      }\n    } else {\n      // ✅ 인자 없으면 rootDir 하위 전체 검사 + ignores 필터\n      targets = await listSourceFiles(analysisRoot, { isIgnored });\n    }\n\n    let hasError = false;\n\n    for (const absPath of targets) {\n      const result = await inspectByType(config.type, absPath, ctx);\n      const diags = result.diagnostics ?? [];\n\n      if (diags.length > 0) {\n        hasError = true;\n        for (const d of diags) {\n          process.stdout.write(formatDiagnostic(result.file.relPath, d) + \"\\n\");\n        }\n      }\n    }\n\n    process.exitCode = hasError ? 1 : 0;\n    return;\n  }\n\n  usage();\n}\n\nmain().catch((e) => {\n  console.error(e?.stack || e);\n  process.exitCode = 1;\n});\n","// src/config/loadConfig.ts\nimport path from \"node:path\";\nimport { pathToFileURL } from \"node:url\";\nimport fs from \"node:fs\";\n\nexport async function loadConfig(repoRoot: string) {\n  const configPath = path.join(repoRoot, \"patternier.config.mjs\");\n\n\n  if (!fs.existsSync(configPath)) {\n    // config 없으면 기본값\n    return { type: \"fsd\" as const };\n  }\n\n  const mod = await import(pathToFileURL(configPath).href);\n\n  const cfg = mod?.config ?? mod?.default ?? null;\n  if (!cfg || typeof cfg !== \"object\") {\n    throw new Error(`Invalid config export in ${configPath}. Export \"config\" object.`);\n  }\n  return cfg;\n}\n","// src/inspect/fsMeta.ts\nimport path from \"node:path\";\n\nconst FSD_LAYERS = [\"app\", \"pages\", \"widgets\", \"features\", \"entities\", \"shared\"] as const;\n\nexport function getFsMeta(absPath: string, repoRoot: string) {\n  const relPath = path.relative(repoRoot, absPath).replaceAll(path.sep, \"/\");\n  const parts = relPath.split(\"/\");\n\n  const layer = (FSD_LAYERS as readonly string[]).includes(parts[0] ?? \"\")\n    ? (parts[0] as (typeof FSD_LAYERS)[number])\n    : \"unknown\";\n\n  // slice: features/<slice>/..., entities/<slice>/...\n  const slice =\n    (layer === \"features\" || layer === \"entities\" || layer === \"widgets\") && parts.length >= 2\n      ? parts[1]\n      : null;\n\n  return {\n    absPath,\n    relPath,\n    layer,\n    slice,\n  };\n}\n","// src/pattern/fsd/parse.ts\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport * as swc from \"@swc/core\";\nimport { makeOffsetToLoc } from \"@/utils/makeOffsetToLoc\";\n\nfunction locFromSpan(\n  span: any,\n  offsetToLoc: (n: number) => { line: number; col: number }\n) {\n  if (!span || typeof span.start !== \"number\") return null;\n  return offsetToLoc(span.start);\n}\n\nexport async function parseFile(absPath: string) {\n  const code = await fs.readFile(absPath, \"utf8\");\n  const { offsetToLoc } = makeOffsetToLoc(code);\n\n  const ext = path.extname(absPath).toLowerCase();\n\n  const syntax = ext === \".ts\" || ext === \".tsx\" ? \"typescript\" : \"ecmascript\";\n  const tsx = ext === \".tsx\" || ext === \".jsx\";\n\n  const ast = await swc.parse(code, {\n    syntax,\n    tsx,\n    decorators: true,\n    dynamicImport: true,\n  } as any);\n\n  const imports: any[] = [];\n  const exports: any[] = [];\n  const requires: any[] = [];\n  const dynamicImports: any[] = [];\n  let useClient = false;\n\n  for (const stmt of (ast as any).body ?? []) {\n    if (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression?.type === \"StringLiteral\" &&\n      stmt.expression.value === \"use client\"\n    ) {\n      useClient = true;\n    }\n\n    if (stmt.type === \"ImportDeclaration\") {\n      imports.push({\n        kind: \"esm\",\n        source: stmt.source?.value ?? null,\n        typeOnly: !!stmt.typeOnly,\n        specifiers: (stmt.specifiers ?? []).map((s: any) => ({\n          type: s.type, // ImportDefaultSpecifier / ImportNamespaceSpecifier / ImportSpecifier\n          local: s.local?.value ?? null,\n          imported: s.imported?.value ?? null,\n        })),\n        loc: locFromSpan(stmt.span, offsetToLoc),\n      });\n      continue;\n    }\n\n    if (stmt.type === \"ExportAllDeclaration\") {\n      exports.push({\n        kind: \"exportAll\",\n        source: stmt.source?.value ?? null,\n        loc: locFromSpan(stmt.span, offsetToLoc),\n      });\n      continue;\n    }\n\n    if (stmt.type === \"ExportNamedDeclaration\") {\n      exports.push({\n        kind: \"exportNamed\",\n        source: stmt.source?.value ?? null,\n        specifiers: (stmt.specifiers ?? []).map((s: any) => ({\n          type: s.type,\n          local: s.orig?.value ?? null,\n          exported: s.exported?.value ?? null,\n        })),\n        loc: locFromSpan(stmt.span, offsetToLoc),\n      });\n      continue;\n    }\n  }\n\n  return {\n    imports,\n    exports,\n    requires,\n    dynamicImports,\n    directives: { useClient },\n  };\n}\n","function makeOffsetToLoc(code: string) {\n    const lineStartOffsets: number[] = [0];\n    for (let i = 0; i < code.length; i++) {\n        if (code[i] === \"\\n\") lineStartOffsets.push(i + 1);\n    }\n\n    function offsetToLoc(offset: number) {\n        // 마지막 lineStartOffsets <= offset 찾기 (이진탐색)\n        let lo = 0, hi = lineStartOffsets.length - 1;\n        while (lo <= hi) {\n        const mid = (lo + hi) >> 1;\n        if (lineStartOffsets[mid] <= offset) lo = mid + 1;\n        else hi = mid - 1;\n        }\n        const lineIndex = Math.max(0, lo - 1);\n        const line = lineIndex + 1;\n        const col = offset - lineStartOffsets[lineIndex] + 1; // 1-based\n        return { line, col };\n    }\n\n    return { offsetToLoc };\n}\n\nexport { makeOffsetToLoc };","export const DEFAULT_FSD_LAYER_ORDER = [\n    \"app\",\n    \"pages\",\n    \"widgets\",\n    \"features\",\n    \"entities\",\n    \"shared\",\n] as const;","import { NormalizedRuleSetting } from \"./nomalizeRule\";\n\nfunction shouldSkipByLayer(fileLayer: string, setting: NormalizedRuleSetting) {\n    if (setting.include?.length) return !setting.include.includes(fileLayer);\n    if (setting.exclude?.length) return setting.exclude.includes(fileLayer);\n    return false;\n  }\n\nexport { shouldSkipByLayer };","type Level = \"off\" | \"warn\" | \"error\";\n\nexport type NormalizedRuleSetting = {\n  level: Level;\n  include?: string[];\n  exclude?: string[];\n  options?: any;\n};\n\nexport function normalizeRuleSetting(x: any, defaultSetting: NormalizedRuleSetting): NormalizedRuleSetting {\n  if (x === \"off\" || x === \"warn\" || x === \"error\") \n    return { \n      level: x, \n      include: defaultSetting.include, \n      exclude: defaultSetting.exclude, \n      options: defaultSetting.options \n    };\n  if (x && typeof x === \"object\") {\n    return {\n      level: (x.level ?? defaultSetting.level) as Level,\n      include: x.include ?? defaultSetting.include,\n      exclude: x.exclude ?? defaultSetting.exclude,\n      options: x.options ?? defaultSetting.options,\n    };\n  }\n\n  return defaultSetting;\n}\n","// src/pattern/fsd/utils/extractTarget.ts\nexport type LayerName = \"app\" | \"pages\" | \"widgets\" | \"features\" | \"entities\" | \"shared\" | string;\n\nconst LAYERS: LayerName[] = [\"app\", \"pages\", \"widgets\", \"features\", \"entities\", \"shared\"];\n\nexport function extractTargetFromSource(source: string): { layer: LayerName; slice: string | null } | null {\n  // 허용 케이스:\n  // \"@/features/auth/...\" or \"features/auth/...\"\n  const normalized = source.startsWith(\"@/\") ? source.slice(2) : source;\n\n  const parts = normalized.split(\"/\").filter(Boolean);\n  const layer = parts[0] as LayerName | undefined;\n\n  if (!layer || !LAYERS.includes(layer)) return null;\n\n  const slice = (layer === \"features\" || layer === \"entities\" || layer === \"widgets\") && parts.length >= 2\n    ? parts[1]\n    : null;\n\n  return { layer, slice };\n}\n\nexport function getLayerIndex(layer: LayerName, order: readonly LayerName[]) {\n  return order.indexOf(layer);\n}\n","// src/pattern/fsd/rules/noLayerToHigherImport.ts\nimport type { LayerName } from \"../utils/extractTarget\";\nimport { extractTargetFromSource, getLayerIndex } from \"../utils/extractTarget\";\n\ntype Loc = { line: number; col: number } | null;\n\nexport type Diagnostic = {\n  ruleId: string;\n  message: string;\n  loc: Loc;\n};\n\nexport type NoLayerToHigherImportOptions = {\n  // 상위 -> 하위 방향을 허용하는 \"정렬\"\n  // app(가장 상위) ... shared(가장 하위)\n  order: readonly LayerName[];\n};\n\nexport function noLayerToHigherImportRule(\n  ctx: {\n    file: { relPath: string; layer: string; slice: string | null };\n    imports: { source: string | null; loc: Loc }[];\n  },\n  opts: NoLayerToHigherImportOptions\n): Diagnostic[] {\n  const diags: Diagnostic[] = [];\n\n  const fromLayer = ctx.file.layer as LayerName;\n  const fromIdx = getLayerIndex(fromLayer, opts.order);\n  if (fromIdx === -1) return diags; // unknown layer면 패스\n\n  for (const im of ctx.imports) {\n    const src = im.source;\n    if (!src) continue;\n\n    const target = extractTargetFromSource(src);\n    if (!target) continue;\n\n    const toIdx = getLayerIndex(target.layer, opts.order);\n    if (toIdx === -1) continue;\n\n    // \"higher\"는 index가 더 작은 쪽(app이 0)\n    const isImportingHigher = toIdx < fromIdx;\n\n    if (isImportingHigher) {\n      diags.push({\n        ruleId: \"@patternier/no-layer-to-higher-import\",\n        message: `${fromLayer} cannot import from higher layer ${target.layer}.`,\n        loc: im.loc ?? null,\n      });\n    }\n  }\n\n  return diags;\n}\n","// src/pattern/fsd/rules/noCrossSliceImport.ts\nimport { extractTargetFromSource } from \"../utils/extractTarget\";\n\ntype Loc = { line: number; col: number } | null;\n\nexport type Diagnostic = {\n  ruleId: string;\n  message: string;\n  loc: Loc;\n};\n\nexport type NoCrossSliceImportOptions = {\n  // 기본: features만 강제\n  layers: readonly string[];\n};\n\nexport function noCrossSliceImportRule(\n  ctx: {\n    file: { relPath: string; layer: string; slice: string | null };\n    imports: { source: string | null; loc: Loc }[];\n  },\n  opts: NoCrossSliceImportOptions\n): Diagnostic[] {\n  const diags: Diagnostic[] = [];\n\n  const fromLayer = ctx.file.layer;\n  const fromSlice = ctx.file.slice;\n\n  if (!opts.layers.includes(fromLayer)) return diags;\n  if (!fromSlice) return diags;\n\n  for (const im of ctx.imports) {\n    const src = im.source;\n    if (!src) continue;\n\n    const target = extractTargetFromSource(src);\n    if (!target) continue;\n\n    // 같은 layer 내에서 slice가 다른 곳으로 가는 것만 금지\n    if (target.layer === fromLayer) {\n      const toSlice = target.slice;\n      if (toSlice && toSlice !== fromSlice) {\n        diags.push({\n          ruleId: \"@patternier/no-cross-slice-import\",\n          message: `${fromLayer}/${fromSlice} cannot import from ${fromLayer}/${toSlice}. Use shared/entities or expose via public API.`,\n          loc: im.loc ?? null,\n        });\n      }\n    }\n  }\n\n  return diags;\n}\n","import { noLayerToHigherImportRule } from \"./noLayerToHigherImport\";\nimport { noCrossSliceImportRule } from \"./noCrossSliceImport\";\n\nexport const fsdRuleRegistry = {\n  \"@patternier/no-layer-to-higher-import\": {\n    run: noLayerToHigherImportRule,\n    default: {\n        level: \"error\",\n    }\n  },\n  \"@patternier/no-cross-slice-import\": {\n    run: noCrossSliceImportRule,\n    default: {\n        level: \"error\",\n        options: { layers: [\"features\"] }\n    }\n  }\n} as const;","// src/pattern/fsd/inspect.ts\nimport { getFsMeta } from \"./fsMeta\";\nimport { parseFile } from \"@/core/parse\";\nimport { PatternConfig } from \"@/config/definePatternConfig\";\nimport { DEFAULT_FSD_LAYER_ORDER } from \"./constants\";\nimport { shouldSkipByLayer } from \"./utils/shouldSkipByLayer\";\nimport { normalizeRuleSetting } from \"./utils/nomalizeRule\";\nimport { fsdRuleRegistry } from \"./rules\";\n\nexport async function inspectFile(absPath: string, ctx: { analysisRoot: string; config: PatternConfig }) {\n  const file = getFsMeta(absPath, ctx.analysisRoot);\n  const parsed = await parseFile(absPath);\n\n  // 룰 옵션에 들어갈 공통 컨텍스트(예: layer order)\n  const layerOrder = ctx.config.layers?.order ?? DEFAULT_FSD_LAYER_ORDER;\n\n  const diagnostics: any[] = [];\n\n  const userRules = ctx.config.rules ?? {};\n\n  for (const [ruleId, rule] of Object.entries(fsdRuleRegistry)) {\n    // 1) 사용자 설정 가져오기 (없으면 default)\n    const userSettingRaw = (userRules as any)[ruleId];\n    const setting = normalizeRuleSetting(userSettingRaw, rule.default);\n\n    // 2) off면 스킵\n    if (setting.level === \"off\") continue;\n\n    // 3) include/exclude(layer 기준) 적용\n    if (shouldSkipByLayer(file.layer, setting)) continue;\n\n    // 4) rule options 구성 (공통 + 유저)\n\n    const options = {\n      // 공통 옵션들\n      order: layerOrder,\n      // 유저가 rule별로 넣은 options\n      ...(setting.options ?? {}),\n    };\n\n    // 5) 실행\n    const diags = rule.run({ file, imports: parsed.imports }, options);\n\n    // 6) level 주입\n    for (const d of diags) {\n      diagnostics.push({ ...d, level: setting.level });\n    }\n  }\n\n  return { file, ...parsed, diagnostics };\n}\n","// src/entry/inspectByType.ts\nimport { PatternType } from \"@/config/definePatternConfig\";\nimport { inspectFile as inspectFsd } from \"../pattern/fsd/inspect\";\n\nexport async function inspectByType(\n  type: PatternType,\n  absPath: string,\n  ctx: { repoRoot: string; analysisRoot: string; config: any }\n) {\n  switch (type) {\n    case \"fsd\":\n      return inspectFsd(absPath, ctx);\n  }\n}\n","export function formatDiagnostic(\n    filePath: string,\n    d: {\n      ruleId: string;\n      message: string;\n      loc?: { line: number; col: number } | null;\n    }\n  ) {\n    const pos = d.loc ? `${d.loc.line}:${d.loc.col}` : \"0:0\";\n    return `${filePath}:${pos}  ${d.ruleId}  ${d.message}`;\n  }\n  ","// src/utils/readIgnoreFile.ts\nimport fs from \"node:fs/promises\";\n\nexport async function readIgnoreFile(absPath: string): Promise<string[]> {\n  try {\n    const raw = await fs.readFile(absPath, \"utf8\");\n    return raw\n      .split(/\\r?\\n/g)\n      .map((l) => l.trim())\n      .filter((l) => l.length > 0)\n      .filter((l) => !l.startsWith(\"#\"));\n  } catch (e: any) {\n    if (e?.code === \"ENOENT\") return [];\n    throw e;\n  }\n}\n"],"mappings":"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","names":["path","fs","path","fs","path","fs","path","fs","path","fs"]}